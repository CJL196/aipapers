# Scalable Diffusion Models with Transformers

William Peebles\* UC Berkeley Saining Xie New York University

![](images/1.jpg)  
F of our class-conditional DiT-XL/2 models trained on ImageNet at $5 1 2 \times 5 1 2$ and $2 5 6 \times 2 5 6$ resolution, respectively.

# Abstract

# 1. Introduction

We explore a new class of diffusion models based on the transformer architecture. We train latent diffusion models of images, replacing the commonly-used U-Net backbone with a transformer that operates on latent patches. We analyze the scalability of our Diffusion Transformers (DiTs) through the lens of forward pass complexity as measured by Gflops. We find that DiTs with higher Gflops—through increased transformer depth/width or increased number of input tokens—consistently have lower FID. In addition to possessing good scalability properties, our largest DiT-XL/2 models outperform all prior diffusion models on the classconditional ImageNet $5 I 2 \times 5 I 2$ and $2 5 6 \times 2 5 6$ benchmarks, achieving a state-of-the-art FID of 2.27 on the latter. Machine learning is experiencing a renaissance powered by transformers. Over the past five years, neural architectures for natural language processing [8, 42], vision [10] and several other domains have largely been subsumed by transformers [60]. Many classes of image-level generative models remain holdouts to the trend, though—while transformers see widespread use in autoregressive models [3,6,43,47], they have seen less adoption in other generative modeling frameworks. For example, diffusion models have been at the forefront of recent advances in image-level generative models [9,46]; yet, they all adopt a convolutional U-Net architecture as the de-facto choice of backbone.

![](images/2.jpg)  
FID-0 urXL/ Ue MDM.

The seminal work of Ho et al. [19] first introduced the U-Net backbone for diffusion models. Having initially seen success within pixel-level autoregressive models and conditional GANs [23], the U-Net was inherited from Pixel$\mathrm { C N N + + }$ [52, 58] with a few changes. The model is convolutional, comprised primarily of ResNet [15] blocks. In contrast to the standard U-Net [49], additional spatial selfattention blocks, which are essential components in transformers, are interspersed at lower resolutions. Dhariwal and Nichol [9] ablated several architecture choices for the UNet, such as the use of adaptive normalization layers [40] to inject conditional information and channel counts for convolutional layers. However, the high-level design of the UNet from Ho et al. has largely remained intact. With this work, we aim to demystify the significance of architectural choices in diffusion models and offer empirical baselines for future generative modeling research. We show that the U-Net inductive bias is not crucial to the performance of diffusion models, and they can be readily replaced with standard designs such as transformers. As a result, diffusion models are well-poised to benefit from the recent trend of architecture unification—e.g., by inheriting best practices and training recipes from other domains, as well as retaining favorable properties like scalability, robustness and efficiency. A standardized architecture would also open up new possibilities for cross-domain research. In this paper, we focus on a new class of diffusion models based on transformers. We call them Diffusion Transformers, or DiTs for short. DiTs adhere to the best practices of Vision Transformers (ViTs) [10], which have been shown to scale more effectively for visual recognition than traditional convolutional networks (e.g., ResNet [15]). More specifically, we study the scaling behavior of transformers with respect to network complexity vs. sample quality. We show that by constructing and benchmarking the DiT design space under the Latent Diffusion Models (LDMs) [48] framework, where diffusion models are trained within a VAE's latent space, we can successfully replace the U-Net backbone with a transformer. We further show that DiTs are scalable architectures for diffusion models: there is a strong correlation between the network complexity (measured by Gflops) vs. sample quality (measured by FID). By simply scaling-up DiT and training an LDM with a high-capacity backbone (118.6 Gflops), we are able to achieve a state-of-the-art result of 2.27 FID on the classconditional $2 5 6 \times 2 5 6$ ImageNet generation benchmark.

# 2. Related Work

Transformers. Transformers [60] have replaced domainspecific architectures across language, vision [10], reinforcement learning [5, 25] and meta-learning [39]. They have shown remarkable scaling properties under increasing model size, training compute and data in the language domain [26], as generic autoregressive models [17] and as ViTs [63]. Beyond language, transformers have been trained to autoregressively predict pixels [6, 7, 38]. They have also been trained on discrete codebooks [59] as both autoregressive models [11,47] and masked generative models [4, 14]; the former has shown excellent scaling behavior up to 20B parameters [62]. Finally, transformers have been explored in DDPMs to synthesize non-spatial data; e.g., to generate CLIP image embeddings in DALL·E 2 [41, 46]. In this paper, we study the scaling properties of transformers when used as the backbone of diffusion models of images.

![](images/3.jpg)

Denoising diffusion probabilistic models (DDPMs). Diffusion [19, 54] and score-based generative models [22, 56] have been particularly successful as generative models of images [35,46,48, 50], in many cases outperforming generative adversarial networks (GANs) [12] which had previously been state-of-the-art. Improvements in DDPMs over the past two years have largely been driven by improved sampling techniques [19, 27, 55], most notably classifierfree guidance [21], reformulating diffusion models to predict noise instead of pixels [19] and using cascaded DDPM pipelines where low-resolution base diffusion models are trained in parallel with upsamplers [9, 20]. For all the diffusion models listed above, convolutional U-Nets [49] are the de-facto choice of backbone architecture. Concurrent work [24] introduced a novel, efficient architecture based on attention for DDPMs; we explore pure transformers. Architecture complexity. When evaluating architecture complexity in the image generation literature, it is fairly common practice to use parameter counts. In general, parameter counts can be poor proxies for the complexity of image models since they do not account for, e.g., image resolution which significantly impacts performance [44, 45]. Instead, much of the model complexity analysis in this paper is through the lens of theoretical Gflops. This brings us in-line with the architecture design literature where Gflops are widely-used to gauge complexity. In practice, the golden complexity metric is still up for debate as it frequently depends on particular application scenarios. Nichol and Dhariwal's seminal work improving diffusion models [9, 36] is most related to us—there, they analyzed the scalability and Gflop properties of the U-Net architecture class. In this paper, we focus on the transformer class.

# 3. Diffusion Transformers

# 3.1. Preliminaries

Diffusion formulation. Before introducing our architecture, we briefly review some basic concepts needed to understand diffusion models (DDPMs) [19, 54]. Gaussian diffusion models assume a forward noising process which gradually applies noise to real data $x _ { 0 }$ : $q ( x _ { t } | x _ { 0 } ) =$ $\mathcal { N } ( x _ { t } ; \sqrt { \bar { \alpha } _ { t } } x _ { 0 } , ( 1 - \bar { \alpha } _ { t } ) \mathbf { I } )$ , where constants $\bar { \alpha } _ { t }$ are hyperparameters. By applying the reparameterization trick, we can sample $x _ { t } = \sqrt { \bar { \alpha } _ { t } } x _ { 0 } + \sqrt { 1 - \bar { \alpha } _ { t } } \epsilon _ { t }$ , where $\epsilon _ { t } \sim \mathcal { N } ( 0 , \bf { I } )$ .

Diffusion models are trained to learn the reverse process that inverts forward process corruptions: $p _ { \theta } ( x _ { t - 1 } | x _ { t } ) \ =$ $\mathcal { N } ( \mu _ { \theta } ( x _ { t } ) , \Sigma _ { \theta } ( x _ { t } ) )$ , where neural networks are used to predict the statistics of $p _ { \theta }$ . The reverse process model is trained with the variational lower bound [30] of the loglikelihood of $x _ { 0 }$ , which reduces to ${ \mathcal { L } } ( \theta ) = - p ( x _ { 0 } | x _ { 1 } ) +$ $\begin{array} { r l } { \sum _ { t } \mathcal { D } _ { K L } \big ( q ^ { * } ( x _ { t - 1 } | x _ { t } , x _ { 0 } ) \big | \big | p _ { \theta } \big ( x _ { t - 1 } | x _ { t } \big ) \big ) } & { { } } \end{array}$ , excluding an additional term irrelevant for training. Since both $q ^ { * }$ and $p _ { \theta }$ are Gaussian, $\mathcal { D } _ { K L }$ can be evaluated with the mean and covariance of the two distributions. By reparameterizing $\mu _ { \theta }$ as a noise prediction network $\epsilon _ { \theta }$ , the model can be trained using simple mean-squared error between the predicted noise $\epsilon _ { \theta } ( x _ { t } )$ and the ground truth sampled Gaussian noise $\epsilon _ { t }$ : $\mathcal { L } _ { s i m p l e } ( \theta ) = | | \epsilon _ { \theta } ( x _ { t } ) - \epsilon _ { t } | | _ { 2 } ^ { 2 }$ But, in order to train diffusion models with a learned reverse process covariance $\Sigma _ { \theta }$ , the full $\mathcal { D } _ { K L }$ term needs to be optimized. We follow Nichol and Dhariwal's approach [36]: train $\epsilon _ { \theta }$ with $\mathcal { L } _ { s i m p l e }$ , and train $\Sigma _ { \theta }$ with the full $\mathcal { L }$ Once $p _ { \theta }$ is trained, new images can be sampled by initializing $x _ { t _ { \operatorname* { m a x } } } \ \sim \ N ( 0 , \mathbf { I } )$ and sampling $x _ { t - 1 } \sim p _ { \theta } ( x _ { t - 1 } | x _ { t } )$ via the reparameterization trick.

Classifier-free guidance. Conditional diffusion models take extra information as input, such as a class label $c$ . In this case, the reverse process becomes $p _ { \theta } ( x _ { t - 1 } | x _ { t } , c )$ , where $\epsilon _ { \theta }$ and $\Sigma _ { \theta }$ are conditioned on $c$ In this setting, classifier-free guidance can be used to encourage the sampling procedure to find $x$ such that $\log p ( c | x )$ is high [21]. By Bayes Rule, $\log p ( c | x ) \propto \log p ( x | c ) - \log p ( x )$ ,and hence $\nabla _ { x } \log p ( c | x ) \propto \nabla _ { x } \log p ( x | c ) - \nabla _ { x } \log p ( x )$ By interpreting the output of diffusion models as the score function, the DDPM sampling procedure can be guided to sample $x$ with high $p ( x | c )$ by: $\hat { \epsilon } _ { \theta } ( x _ { t } , c ) ~ = ~ \epsilon _ { \theta } ( x _ { t } , \emptyset ) + s ~ .$ $\nabla _ { \boldsymbol { x } } \log { p ( \boldsymbol { x } | \boldsymbol { c } ) } \propto \epsilon _ { \theta } ( x _ { t } , \emptyset ) + s \cdot ( \epsilon _ { \theta } ( x _ { t } , \boldsymbol { c } ) - \epsilon _ { \theta } ( x _ { t } , \emptyset ) )$ , where $s > 1$ indicates the scale of the guidance (note that $s = 1$ recovers standard sampling). Evaluating the diffusion model with $c = \emptyset$ is done by randomly dropping out $c$ during training and replacing it with a learned "null" embedding $\varnothing$ Classifier-free guidance is widely-known to yield significantly improved samples over generic sampling techniques [21, 35, 46], and the trend holds for our DiT models. Latent diffusion models. Training diffusion models directly in high-resolution pixel space can be computationally prohibitive. Latent diffusion models (LDMs) [48] tackle this issue with a two-stage approach: (1) learn an autoencoder that compresses images into smaller spatial representations with a learned encoder $E$ ; (2) train a diffusion model of representations $z = E ( x )$ instead of a diffusion model of images $x$ $E$ is frozen). New images can then be generated by sampling a representation $z$ from the diffusion model and subsequently decoding it to an image with the learned decoder $x = D ( z )$ . As shown in Figure 2, LDMs achieve good performance while using a fraction of the Gflops of pixel space diffusion models like ADM. Since we are concerned with compute efficiency, this makes them an appealing starting point for architecture exploration. In this paper, we apply DiTs to latent space, although they could be applied to pixel space without modification as well. This makes our image generation pipeline a hybrid-based approach; we use off-the-shelf convolutional VAEs and transformer-based DDPMs.

# 3.2. Diffusion Transformer Design Space

We introduce Diffusion Transformers (DiTs), a new architecture for diffusion models. We aim to be as faithful to the standard transformer architecture as possible to retain its scaling properties. Since our focus is training DDPMs of images (specifically, spatial representations of images), DiT is based on the Vision Transformer (ViT) architecture which operates on sequences of patches [10]. DiT retains many of the best practices of ViTs. Figure 3 shows an overview of the complete DiT architecture. In this section, we describe the forward pass of DiT, as well as the components of the design space of the DiT class.

![](images/4.jpg)  
Figure 4. Input specifications for DiT. Given patch size $p \times p$ a spatial representation (the noised latent from the VAE) of shape $I \times I \times C$ is "patchified" into a sequence of length $T = ( I / p ) ^ { 2 }$ with hidden dimension $d$ A smaller patch size $p$ results in a longer sequence length and thus more Gflops.

Patchify. The input to DiT is a spatial representation $z$ (for $2 5 6 \times 2 5 6 \times 3$ images, $z$ has shape $3 2 \times 3 2 \times 4 )$ . The first layer of DiT is "patchify," which converts the spatial input into a sequence of $T$ tokens, each of dimension $d$ , by linearly embedding each patch in the input. Following patchify, we apply standard ViT frequency-based positional embeddings (the sine-cosine version) to all input tokens. The number of tokens $T$ created by patchify is determined by the patch size hyperparameter $p$ .As shown in Figure 4, halving $p$ will quadruple $T$ , and thus at least quadruple total transformer Gflops. Although it has a significant impact on Gflops, note that changing $p$ has no meaningful impact on downstream parameter counts. We add $p = 2 , 4 , 8$ to the DiT design space. DiT block design. Following patchify, the input tokens are processed by a sequence of transformer blocks. In addition to noised image inputs, diffusion models sometimes process additional conditional information such as noise timesteps $t$ , class labels $c$ , natural language, etc. We explore four variants of transformer blocks that process conditional inputs differently. The designs introduce small, but important, modifications to the standard ViT block design. The designs of all blocks are shown in Figure 3. In-context conditioning. We simply append the vector embeddings of $t$ and $c$ as two additional tokens in the input sequence, treating them no differently from the image tokens. This is similar to ${ \mathsf { C l } } { \mathsf { S } }$ tokens in ViTs, and it allows us to use standard ViT blocks without modification. After the final block, we remove the conditioning tokens from the sequence. This approach introduces negligible new Gflops to the model.

![](images/5.jpg)  
Figure 5. Comparing different conditioning strategies. adaLNZero outperforms cross-attention and in-context conditioning at all stages of training.

Cross-attention block. We concatenate the embeddings of $t$ and $c$ into a length-two sequence, separate from the image token sequence. The transformer block is modified to include an additional multi-head crossattention layer following the multi-head self-attention block, similar to the original design from Vaswani et al. [60], and also similar to the one used by LDM for conditioning on class labels. Cross-attention adds the most Gflops to the model, roughly a $15 \%$ overhead. Adaptive layer norm (adaLN) block. Following the widespread usage of adaptive normalization layers [40] in GANs [2, 28] and diffusion models with UNet backbones [9], we explore replacing standard layer norm layers in transformer blocks with adaptive layer norm (adaLN). Rather than directly learn dimensionwise scale and shift parameters $\gamma$ and $\beta$ , we regress them from the sum of the embedding vectors of $t$ and $c$ . Of the three block designs we explore, adaLN adds the least Gflops and is thus the most compute-efficient. It is also the only conditioning mechanism that is restricted to apply the same function to all tokens. adaLN-Zero block. Prior work on ResNets has found that initializing each residual block as the identity function is beneficial. For example, Goyal et al. found that zero-initializing the final batch norm scale factor $\gamma$ in each block accelerates large-scale training in the supervised learning setting [13]. Diffusion U-Net models use a similar initialization strategy, zero-initializing the final convolutional layer in each block prior to any residual connections. We explore a modification of the adaLN DiT block which does the same. In addition to regressing $\gamma$ and $\beta$ , we also regress dimensionwise scaling parameters $\alpha$ that are applied immediately prior to any residual connections within the DiT block.

Table 1. Details of DiT models. We follow ViT [10] model configurations for the Small (S), Base (B) and Large (L) variants; we also introduce an XLarge (XL) config as our largest model.   

<table><tr><td>Model</td><td>Layers N</td><td>Hidden size d</td><td>Heads</td><td>Gflops (I=32, p=4)</td></tr><tr><td>DiT-S</td><td>12</td><td>384</td><td>6</td><td>1.4</td></tr><tr><td>DiT-B</td><td>12</td><td>768</td><td>12</td><td>5.6</td></tr><tr><td>DiT-L</td><td>24</td><td>1024</td><td>16</td><td>19.7</td></tr><tr><td>DiT-XL</td><td>28</td><td>1152</td><td>16</td><td>29.1</td></tr></table>

We initialize the MLP to output the zero-vector for all $\alpha$ ; this initializes the full DiT block as the identity function. As with the vanilla adaLN block, adaLNZero adds negligible Gflops to the model. We include the in-context, cross-attention, adaptive layer norm and adaLN-Zero blocks in the DiT design space. Model size. We apply a sequence of $N$ DiT blocks, each operating at the hidden dimension size $d$ Following ViT, we use standard transformer configs that jointly scale $N$ , $d$ and attention heads [10, 63]. Specifically, we use four configs: DiT-S, DiT-B, DiT-L and DiT-XL. They cover a wide range of model sizes and flop allocations, from 0.3 to 118.6 Gflops, allowing us to gauge scaling performance. Table 1 gives details of the configs. We add B, S, L and XL configs to the DiT design space. Transformer decoder. After the final DiT block, we need to decode our sequence of image tokens into an output noise prediction and an output diagonal covariance prediction. Both of these outputs have shape equal to the original spatial input. We use a standard linear decoder to do this; we apply the final layer norm (adaptive if using adaLN) and linearly decode each token into a $p \times p \times 2 C$ tensor, where $C$ is the number of channels in the spatial input to DiT. Finally, we rearrange the decoded tokens into their original spatial layout to get the predicted noise and covariance. The complete DiT design space we explore is patch size, transformer block architecture and model size.

# 4. Experimental Setup

We explore the DiT design space and study the scaling properties of our model class. Our models are named according to their configs and latent patch sizes $p$ ; for example, DiT-XL/2 refers to the XLarge config and $p = 2$ . Training. We train class-conditional latent DiT models at $2 5 6 \times 2 5 6$ and $5 1 2 \times 5 1 2$ image resolution on the ImageNet dataset [31], a highly-competitive generative modeling benchmark. We initialize the final linear layer with zeros and otherwise use standard weight initialization techniques from ViT. We train all models with AdamW [29,33].

![](images/6.jpg)  
F transformer backbone yields better generative models across all model sizes and patch sizes.

We use a constant learning rate of $1 \times 1 0 ^ { - 4 }$ , no weight decay and a batch size of 256. The only data augmentation we use is horizontal flips. Unlike much prior work with ViTs [57, 61], we did not find learning rate warmup nor regularization necessary to train DiTs to high performance. Even without these techniques, training was highly stable across all model configs and we did not observe any loss spikes commonly seen when training transformers. Following common practice in the generative modeling literature, we maintain an exponential moving average (EMA) of DiT weights over training with a decay of 0.9999. All results reported use the EMA model. We use identical training hyperparameters across all DiT model sizes and patch sizes. Our training hyperparameters are almost entirely retained from ADM. We did not tune learning rates, decay/warm-up schedules, Adam $\beta _ { 1 } / \beta _ { 2 }$ or weight decays.

Diffusion. We use an off-the-shelf pre-trained variational autoencoder (VAE) model [30] from Stable Diffusion [48]. The VAE encoder has a downsample factor of 8—given an RGB image $x$ with shape $2 5 6 \times 2 5 6 \times 3$ $z = E ( x )$ has shape $3 2 \times 3 2 \times 4$ Across all experiments in this section, our diffusion models operate in this $\mathcal { Z }$ -space. After sampling a new latent from our diffusion model, we decode it to pixels using the VAE decoder $x = D ( z )$ . We retain diffusion hyperparameters from ADM [9]; specifically, we use a $t _ { \mathrm { m a x } } = 1 0 0 0$ linear variance schedule ranging from $1 \times 1 0 ^ { - 4 }$ to $2 \times 1 0 ^ { - 2 }$ , ADM's parameterization of the covariance $\Sigma _ { \theta }$ and their method for embedding input timesteps and labels. Evaluation metrics. We measure scaling performance with Fréchet Inception Distance (FID) [18], the standard metric for evaluating generative models of images. We follow convention when comparing against prior works and report FID-50K using 250 DDPM sampling steps. FID is known to be sensitive to small implementation details [37]; to ensure accurate comparisons, all values reported in this paper are obtained by exporting samples and using ADM's TensorFlow evaluation suite [9]. FID numbers reported in this section do not use classifier-free guidance except where otherwise stated. We additionally report Inception Score [51], sFID [34] and Precision/Recall [32] as secondary metrics. Compute. We implement all models in JAX [1] and train them using TPU-v3 pods. DiT-XL/2, our most computeintensive model, trains at roughly 5.7 iterations/second on a TPU v3-256 pod with a global batch size of 256.

# 5. Experiments

DiT block design. We train four of our highest Gflop DiT-XL/2 models, each using a different block design— in-context (119.4 Gflops), cross-attention (137.6 Gflops), adaptive layer norm (adaLN, 118.6 Gflops) or adaLN-zero (118.6 Gflops). We measure FID over the course of training. Figure 5 shows the results. The adaLN-Zero block yields lower FID than both cross-attention and in-context conditioning while being the most compute-efficient. At 400K training iterations, the FID achieved with the adaLN-Zero model is nearly half that of the in-context model, demonstrating that the conditioning mechanism critically affects model quality. Initialization is also important—adaLNZero, which initializes each DiT block as the identity function, significantly outperforms vanilla adaLN. For the rest of the paper, all models will use adaLN-Zero DiT blocks.

![](images/7.jpg)

![](images/8.jpg)  
Figure 8. Transformer Gflops are strongly correlated with FID. We plot the Gflops of each of our DiT models and each model's FID-50K after 400K training steps.

Scaling model size and patch size. We train 12 DiT models, sweeping over model configs (S, B, L, XL) and patch sizes (8, 4, 2). Note that DiT-L and DiT-XL are significantly closer to each other in terms of relative Gflops than other configs. Figure 2 (left) gives an overview of the Gflops of each model and their FID at 400K training iterations. In all cases, we find that increasing model size and decreasing patch size yields considerably improved diffusion models. Figure 6 (top) demonstrates how FID changes as model size is increased and patch size is held constant. Across all four configs, significant improvements in FID are obtained over all stages of training by making the transformer deeper and wider. Similarly, Figure 6 (bottom) shows FID as patch size is decreased and model size is held constant. We again observe considerable FID improvements throughout training by simply scaling the number of tokens processed by DiT, holding parameters approximately fixed.

DiT Gflops are critical to improving performance. The results of Figure 6 suggest that parameter counts do not uniquely determine the quality of a DiT model. As model size is held constant and patch size is decreased, the transformer's total parameters are effectively unchanged (actually, total parameters slightly decrease), and only Gflops are increased. These results indicate that scaling model Gflops is actually the key to improved performance. To investigate this further, we plot the FID-50K at 400K training steps against model Gflops in Figure 8. The results demonstrate that different DiT configs obtain similar FID values when their total Gflops are similar (e.g., DiT-S/2 and DiT-B/4). We find a strong negative correlation between model Gflops and FID-50K, suggesting that additional model compute is the critical ingredient for improved DiT models. In Figure 12 (appendix), we find that this trend holds for other metrics such as Inception Score.

![](images/9.jpg)  
Figure 9. Larger DiT models use large compute more efficiently. We plot FID as a function of total training compute.

Larger DiT models are more compute-efficient. In Figure 9, we plot FID as a function of total training compute for all DiT models. We estimate training compute as model Gflops $\cdot$ batch size $\cdot$ training steps · 3, where the factor of 3 roughly approximates the backwards pass as being twice as compute-heavy as the forward pass. We find that small DiT models, even when trained longer, eventually become compute-inefficient relative to larger DiT models trained for fewer steps. Similarly, we find that models that are identical except for patch size have different performance profiles even when controlling for training Gflops. For example, $\mathrm { X L } / 4$ is outperformed by XL/2 after roughly $1 0 ^ { 1 0 }$ Gflops. Visualizing scaling. We visualize the effect of scaling on sample quality in Figure 7. At 400K training steps, we sample an image from each of our $1 2 \mathrm { D i T }$ models using identical starting noise $x _ { t _ { \operatorname* { m a x } } }$ , sampling noise and class labels. This lets us visually interpret how scaling affects DiT sample quality. Indeed, scaling both model size and the number of tokens yields notable improvements in visual quality.

# 5.1. State-of-the-Art Diffusion Models $2 5 6 \times 2 5 6$ ImageNet. Following our scaling analysis, we continue training our highest Gflop model, DiT-XL/2, for 7M steps. We show samples from the model in Figures 1, and we compare against state-of-the-art class-conditional generative models. We report results in Table 2. When using classifier-free guidance, DiT-XL/2 outperforms all prior diffusion models, decreasing the previous best FID-50K of 3.60 achieved by LDM to 2.27. Figure 2 (right) shows that DiT-XL/2 (118.6 Gflops) is compute-efficient relative to latent space U-Net models like LDM-4 (103.6 Gflops) and substantially more efficient than pixel space U-Net models such as ADM (1120 Gflops) or ADM-U (742 Gflops).

Table 2. Benchmarking class-conditional image generation on ImageNet $2 5 6 \times 2 5 6 .$ DiT-XL/2 achieves state-of-the-art FID.   

<table><tr><td colspan="6">Class-Conditional ImageNet 256×256</td></tr><tr><td>Model</td><td>FID↓</td><td>sFID↓</td><td>IS↑</td><td>Precision↑</td><td>Recall↑</td></tr><tr><td>BigGAN-deep [2]</td><td>6.95</td><td>7.36</td><td>171.4</td><td>0.87</td><td>0.28</td></tr><tr><td>StyleGAN-XL [53]</td><td>2.30</td><td>4.02</td><td>265.12</td><td>0.78</td><td>0.53</td></tr><tr><td>ADM [9]</td><td>10.94</td><td>6.02</td><td>100.98</td><td>0.69</td><td>0.63</td></tr><tr><td>ADM-U</td><td>7.49</td><td>5.13</td><td>127.49</td><td>0.72</td><td>0.63</td></tr><tr><td>ADM-G</td><td>4.59</td><td>5.25</td><td>186.70</td><td>0.82</td><td>0.52</td></tr><tr><td>ADM-G, ADM-U</td><td>3.94</td><td>6.14</td><td>215.84</td><td>0.83</td><td>0.53</td></tr><tr><td>CDM [20]</td><td>4.88</td><td>-</td><td>158.71</td><td>-</td><td>-</td></tr><tr><td>LDM-8 [48]</td><td>15.51</td><td>-</td><td>79.03</td><td>0.65</td><td>0.63</td></tr><tr><td>LDM-8-G</td><td>7.76</td><td>-</td><td>209.52</td><td>0.84</td><td>0.35</td></tr><tr><td>LDM-4</td><td>10.56</td><td>-</td><td>103.49</td><td>0.71</td><td>0.62</td></tr><tr><td>LDM-4-G (cfg=1.25)</td><td>3.95</td><td>-</td><td>178.22</td><td>0.81</td><td>0.55</td></tr><tr><td>LDM-4-G (cfg=1.50)</td><td>3.60</td><td>-</td><td>247.67</td><td>0.87</td><td>0.48</td></tr><tr><td>DiT-XL/2</td><td>9.62</td><td>6.85</td><td>121.50</td><td>0.67</td><td>0.67</td></tr><tr><td>DiT-XL/2-G (cfg=1.25)</td><td>3.22</td><td>5.28</td><td>201.77</td><td>0.76</td><td>0.62</td></tr><tr><td>DiT-XL/2-G (cfg=1.50)</td><td>2.27</td><td>4.60</td><td>278.24</td><td>0.83</td><td>0.57</td></tr></table>

Table 3. Benchmarking class-conditional image generation on ImageNet ${ \bf 5 1 2 } \times { \bf 5 1 2 }$ Note that prior work [9] measures Precision and Recall using 1000 real samples for $5 1 2 \times 5 1 2$ resolution; for consistency, we do the same.   

<table><tr><td colspan="6">Class-Conditional ImageNet 512×512</td></tr><tr><td>Model</td><td>FID↓</td><td>sFID↓</td><td>IS↑</td><td>Precision↑</td><td>Recall↑</td></tr><tr><td>BigGAN-deep [2]</td><td>8.43</td><td>8.13</td><td>177.90</td><td>0.88</td><td>0.29</td></tr><tr><td>StyleGAN-XL [53]</td><td>2.41</td><td>4.06</td><td>267.75</td><td>0.77</td><td>0.52</td></tr><tr><td>ADM [9]</td><td>23.24</td><td>10.19</td><td>58.06</td><td>0.73</td><td>0.60</td></tr><tr><td>ADM-U</td><td>9.96</td><td>5.62</td><td>121.78</td><td>0.75</td><td>0.64</td></tr><tr><td>ADM-G</td><td>7.72</td><td>6.57</td><td>172.71</td><td>0.87</td><td>0.42</td></tr><tr><td>ADM-G, ADM-U</td><td>3.85</td><td>5.86</td><td>221.72</td><td>0.84</td><td>0.53</td></tr><tr><td>DiT-XL/2</td><td>12.03</td><td>7.12</td><td>105.25</td><td>0.75</td><td>0.64</td></tr><tr><td>DiT-XL/2-G (cfg=1.25)</td><td>4.64</td><td>5.77</td><td>174.77</td><td>0.81</td><td>0.57</td></tr><tr><td>DiT-XL/2-G (cfg=1.50)</td><td>3.04</td><td>5.02</td><td>240.82</td><td>0.84</td><td>0.54</td></tr></table>

Our method achieves the lowest FID of all prior generative models, including the previous state-of-the-art StyleGANXL [53]. Finally, we also observe that DiT-XL/2 achieves higher recall values at all tested classifier-free guidance scales compared to LDM-4 and LDM-8. When trained for only 2.35M steps (similar to ADM), XL/2 still outperforms all prior diffusion models with an FID of 2.55.

${ \bf 5 1 2 } \times { \bf 5 1 2 }$ ImageNet. We train a new DiT-XL/2 model on ImageNet at $5 1 2 \times 5 1 2$ resolution for 3M iterations with identical hyperparameters as the $2 5 6 \times 2 5 6$ model. With a patch size of 2, this XL/2 model processes a total of 1024 tokens after patchifying the $6 4 \times 6 4 \times 4$ input latent (524.6 Gflops). Table 3 shows comparisons against state-of-the-art methods. XL/2 again outperforms all prior diffusion models at this resolution, improving the previous best FID of 3.85 achieved by ADM to 3.04. Even with the increased number of tokens, XL/2 remains compute-efficient. For example, ADM uses 1983 Gflops and ADM-U uses 2813 Gflops; XL/2 uses 524.6 Gflops. We show samples from the highresolution XL/2 model in Figure 1 and the appendix.

![](images/10.jpg)  
Figure 10. Scaling-up sampling compute does not compensate for a lack of model compute. For each of our DiT models trained for 400K iterations, we compute FID-10K using [16, 32, 64, 128, 256, 1000] sampling steps. For each number of steps, we plot the FID as well as the Gflops used to sample each image. Small models cannot close the performance gap with our large models, even if they sample with more test-time Gflops than the large models.

# 5.2. Scaling Model vs. Sampling Compute

Diffusion models are unique in that they can use additional compute after training by increasing the number of sampling steps when generating an image. Given the impact of model Gflops on sample quality, in this section we study if smaller-model compute DiTs can outperform larger ones by using more sampling compute. We compute FID for all 12 of our DiT models after 400K training steps, using [16, 32, 64, 128, 256, 1000] sampling steps per-image. The main results are in Figure 10. Consider DiT-L/2 using 1000 sampling steps versus DiT-XL/2 using 128 steps. In this case, L/2 uses 80.7 Tflops to sample each image; XL/2 uses $5 \times$ less compute—15.2 Tflops—to sample each image. Nonetheless, XL/2 has the better FID-10K (23.7 vs 25.9). In general, scaling-up sampling compute cannot compensate for a lack of model compute.

# 6. Conclusion

We introduce Diffusion Transformers (DiTs), a simple transformer-based backbone for diffusion models that outperforms prior U-Net models and inherits the excellent scaling properties of the transformer model class. Given the promising scaling results in this paper, future work should continue to scale DiTs to larger models and token counts. DiT could also be explored as a drop-in backbone for textto-image models like DALL·E 2 and Stable Diffusion. Acknowledgements. We thank Kaiming He, Ronghang Hu, Alexander Berg, Shoubhik Debnath, Tim Brooks, Ilija Radosavovic and Tete Xiao for helpful discussions. William Peebles is supported by the NSF GRFP.

# References

[1] James Bradbury, Roy Frostig, Peter Hawkins, Matthew James Johnson, Chris Leary, Dougal Maclaurin, George Necula, Adam Paszke, Jake VanderPlas, Skye Wanderman-Milne, and Qiao Zhang. JAX: composable transformations of Python+NumPy programs, 2018. 6 [2] Andrew Brock, Jeff Donahue, and Karen Simonyan. Large scale GAN training for high fidelity natural image synthesis. In ICLR, 2019. 5, 9 [3] Tom B Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. Language models are few-shot learners. In NeurIPS, 2020. 1 [4] Huiwen Chang, Han Zhang, Lu Jiang, Ce Liu, and William T Freeman. Maskgit: Masked generative image transformer. In CVPR, pages 1131511325, 2022. 2 [5] Lili Chen, Kevin Lu, Aravind Rajeswaran, Kimin Lee, Aditya Grover, Misha Laskin, Pieter Abbeel, Aravind Srinivas, and Igor Mordatch. Decision transformer: Reinforcement learning via sequence modeling. In NeurIPS, 2021. 2 [6] Mark Chen, Alec Radford, Rewon Child, Jeffrey Wu, Heewoo Jun, David Luan, and Ilya Sutskever. Generative pretraining from pixels. In ICML, 2020. 1, 2 [7] Rewon Child, Scott Gray, Alec Radford, and Ilya Sutskever. Generating long sequences with sparse transformers. arXiv preprint arXiv:1904.10509, 2019. 2 [8] Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. Bert: Pre-training of deep bidirectional transformers for language understanding. In NAACL-HCT, 2019.   
1 [9] Prafulla Dhariwal and Alexander Nichol. Diffusion models beat gans on image synthesis. In NeurIPS, 2021. 1, 2, 3, 5,   
6, 9, 12 [10] Alexey Dosovitskiy, Lucas Beyer, Alexander Kolesnikov, Dirk Weissenborn, Xiaohua Zhai, Thomas Unterthiner, Mostafa Dehghani, Matthias Minderer, Georg Heigold, Sylvain Gelly, et al. An image is worth 16x16 words: Transformers for image recognition at scale. In ICLR, 2020. 1, 2,   
4,5 [11] Patrick Esser, Robin Rombach, and Björn Ommer. Taming transformers for high-resolution image synthesis, 2020. 2 [12] Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair, Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In NIPS, 2014.   
3 [13] Priya Goyal, Piotr Dollár, Ross Girshick, Pieter Noordhuis, Lukasz Wesolowski, Aapo Kyrola, Andrew Tulloch, Yangqing Jia, and Kaiming He. Accurate, large minibatch sgd: Training imagenet in 1 hour. arXiv:1706.02677, 2017.   
5 [14] Shuyang Gu, Dong Chen, Jianmin Bao, Fang Wen, Bo Zhang, Dongdong Chen, Lu Yuan, and Baining Guo. Vector quantized diffusion model for text-to-image synthesis. In CVPR, pages 1069610706, 2022. 2 [15] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In CVPR,   
2016.2   
[16] Dan Hendrycks and Kevin Gimpel. Gaussian error linear units (gelus). arXiv preprint arXiv:1606.08415, 2016. 12   
[17] Tom Henighan, Jared Kaplan, Mor Katz, Mark Chen, Christopher Hesse, Jacob Jackson, Heewoo Jun, Tom B Brown, Prafulla Dhariwal, Scott Gray, et al. Scaling laws for autoregressive generative modeling. arXiv preprint arXiv:2010.14701, 2020. 2   
[18] Martin Heusel, Hubert Ramsauer, Thomas Unterthiner, Bernhard Nessler, and Sepp Hochreiter. Gans trained by a two time-scale update rule converge to a local nash equilibrium. 2017. 6   
[19] Jonathan Ho, Ajay Jain, and Pieter Abbeel. Denoising diffusion probabilistic models. In NeurIPS, 2020. 2, 3   
[20] Jonathan Ho, Chitwan Saharia, William Chan, David J Fleet, Mohammad Norouzi, and Tim Salimans. Cascaded diffusion models for high fidelity image generation. arXiv:2106.15282, 2021. 3, 9   
[21] Jonathan Ho and Tim Salimans. Classifier-free diffusion guidance. In NeurIPS 2021 Workshop on Deep Generative Models and Downstream Applications, 2021. 3, 4   
[22] Aapo Hyvärinen and Peter Dayan. Estimation of nonnormalized statistical models by score matching. Journal of Machine Learning Research, 6(4), 2005. 3   
[23] Phillip Isola, Jun-Yan Zhu, Tinghui Zhou, and Alexei A Efros. Image-to-image translation with conditional adversarial networks. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages 11251134, 2017. 2   
[24] Allan Jabri, David Fleet, and Ting Chen. Scalable adaptive computation for iterative generation. arXiv preprint arXiv:2212.11972, 2022. 3   
[25] Michael Janner, Qiyang Li, and Sergey Levine. Offline reinforcement learning as one big sequence modeling problem. In NeurIPS, 2021. 2   
[26] Jared Kaplan, Sam McCandlish, Tom Henighan, Tom B Brown, Benjamin Chess, Rewon Child, Scott Gray, Alec Radford, Jeffrey Wu, and Dario Amodei. Scaling laws for neural language models. arXiv:2001.08361, 2020. 2, 13   
[27] Tero Karras, Miika Aittala, Timo Aila, and Samuli Laine. Elucidating the design space of diffusion-based generative models. In Proc. NeurIPS, 2022. 3   
[28] Tero Karras, Samuli Laine, and Timo Aila. A style-based generator architecture for generative adversarial networks. In CVPR, 2019. 5   
[29] Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In ICLR, 2015. 5   
[30] Diederik P Kingma and Max Welling. Auto-encoding variational bayes. arXiv preprint arXiv:1312.6114, 2013. 3, 6   
[31] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classification with deep convolutional neural networks. In NeurIPS, 2012. 5   
[32] Tuomas Kynkäänniemi, Tero Karras, Samuli Laine, Jaakko Lehtinen, and Timo Aila. Improved precision and recall metric for assessing generative models. In NeurIPS, 2019. 6   
[33] Ilya Loshchilov and Frank Hutter. Decoupled weight decay regularization. arXiv:1711.05101. 2017. 5   
[34] Charlie Nash, Jacob Menick, Sander Dieleman, and Peter W Battaglia. Generating images with sparse representations. arXiv preprint arXiv:2103.03841, 2021. 6   
[35] Alex Nichol, Prafulla Dhariwal, Aditya Ramesh, Pranav Shyam, Pamela Mishkin, Bob McGrew, Ilya Sutskever, and Mark Chen. Glide: Towards photorealistic image generation and editing with text-guided diffusion models. arXiv:2112.10741, 2021. 3, 4   
[36] Alexander Quinn Nichol and Prafulla Dhariwal. Improved denoising diffusion probabilistic models. In ICML, 2021. 3   
[37] Gaurav Parmar, Richard Zhang, and Jun-Yan Zhu. On aliased resizing and surprising subtleties in gan evaluation. In CVPR, 2022. 6   
[38] Niki Parmar, Ashish Vaswani, Jakob Uszkoreit, Lukasz Kaiser, Noam Shazeer, Alexander Ku, and Dustin Tran. Image transformer. In International conference on machine learning, pages 40554064. PMLR, 2018. 2   
[39] William Peebles, Ilija Radosavovic, Tim Brooks, Alexei Efros, and Jitendra Malik. Learning to learn with generative models of neural network checkpoints. arXiv preprint arXiv:2209.12892, 2022. 2   
[40] Ethan Perez, Florian Strub, Harm De Vries, Vincent Dumoulin, and Aaron Courville. Film: Visual reasoning with a general conditioning layer. In AAAI, 2018. 2, 5   
[41] Alec Radford, Jong Wook Kim, Chris Hallacy, Aditya Ramesh, Gabriel Goh, Sandhini Agarwal, Girish Sastry, Amanda Askell, Pamela Mishkin, Jack Clark, et al. Learning transferable visual models from natural language supervision. In ICML, 2021. 2   
[42] Alec Radford, Karthik Narasimhan, Tim Salimans, and Ilya Sutskever. Improving language understanding by generative pre-training. 2018. 1   
[43] Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, Ilya Sutskever, et al. Language models are unsupervised multitask learners. 2019. 1   
[44] Ilija Radosavovic, Justin Johnson, Saining Xie, Wan-Yen Lo, and Piotr Dollár. On network design spaces for visual recognition. In ICCV, 2019. 3   
[45] Ilija Radosavovic, Raj Prateek Kosaraju, Ross Girshick, Kaiming He, and Piotr Dollár. Designing network design spaces. In CVPR, 2020. 3   
[46] Aditya Ramesh, Prafulla Dhariwal, Alex Nichol, Casey Chu, and Mark Chen. Hierarchical text-conditional image generation with clip latents. arXiv:2204.06125, 2022. 1, 2, 3, 4   
[47] Aditya Ramesh, Mikhail Pavlov, Gabriel Goh, Scott Gray, Chelsea Voss, Alec Radford, Mark Chen, and Ilya Sutskever. Zero-shot text-to-image generation. In ICML, 2021. 1, 2   
[48] Robin Rombach, Andreas Blattmann, Dominik Lorenz, Patrick Esser, and Björn Ommer. High-resolution image synthesis with latent diffusion models. In CVPR, 2022. 2, 3, 4, 6, 9   
[49] Olaf Ronneberger, Philipp Fischer, and Thomas Brox. Unet: Convolutional networks for biomedical image segmentation. In International Conference on Medical image computing and computer-assisted intervention, pages 234241. Springer, 2015. 2, 3 [50] Chitwan Saharia, William Chan, Saurabh Saxena, Lala Li, Jay Whang, Emily Denton, Seyed Kamyar Seyed Ghasemipour, Burcu Karagol Ayan, S. Sara Mahdavi, Rapha Gontijo Lopes, Tim Salimans, Jonathan Ho, David J Fleet, and Mohammad Norouzi. Photorealistic text-toimage diffusion models with deep language understanding. arXiv:2205.11487, 2022. 3 [51] Tim Salimans, Ian Goodfellow, Wojciech Zaremba, Vicki Cheung, Alec Radford, Xi Chen, and Xi Chen. Improved techniques for training GANs. In NeurIPS, 2016. 6 [52] Tim Salimans, Andrej Karpathy, Xi Chen, and Diederik P Kingma. PixelCNN++: Improving the pixelcnn with discretized logistic mixture likelihood and other modifications. arXiv preprint arXiv:1701.05517, 2017. 2 [53] Axel Sauer, Katja Schwarz, and Andreas Geiger. Styleganxl: Scaling stylegan to large diverse datasets. In SIGGRAPH,   
2022. 9 [54] Jascha Sohl-Dickstein, Eric Weiss, Niru Maheswaranathan, and Surya Ganguli. Deep unsupervised learning using nonequilibrium thermodynamics. In ICML, 2015. 3 [55] Jiaming Song, Chenlin Meng, and Stefano Ermon. Denoising diffusion implicit models. arXiv:2010.02502, 2020. 3 [56] Yang Song and Stefano Ermon. Generative modeling by estimating gradients of the data distribution. In NeurIPS, 2019.   
3 [57] Andreas Steiner, Alexander Kolesnikov, Xiaohua Zhai, Ross Wightman, Jakob Uszkoreit, and Lucas Beyer. How to train your ViT? data, augmentation, and regularization in vision transformers. TMLR, 2022.6 [58] Aaron Van den Oord, Nal Kalchbrenner, Lasse Espeholt, Oriol Vinyals, Alex Graves, et al. Conditional image generation with pixelcnn decoders. Advances in neural information processing systems, 29, 2016. 2 [59] Aaron Van Den Oord, Oriol Vinyals, et al. Neural discrete representation learning. Advances in neural information processing systems, 30, 2017. 2 [60] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Eukasz Kaiser, and Illia Polosukhin. Attention is all you need. In NeurIPS, 2017. 1,   
2,5 [61] Tete Xiao, Piotr Dollar, Mannat Singh, Eric Mintun, Trevor Darrell, and Ross Girshick. Early convolutions help transformers see better. In NeurIPS, 2021. 6 [62] Jiahui Yu, Yuanzhong Xu, Jing Yu Koh, Thang Luong, Gunjan Baid, Zirui Wang, Vijay Vasudevan, Alexander Ku, Yinfei Yang, Burcu Karagol Ayan, et al. Scaling autoregressive models for content-rich text-to-image generation. arXiv:2206.10789, 2022. 2 [63] Xiaohua Zhai, Alexander Kolesnikov, Neil Houlsby, and Lucas Beyer. Scaling vision transformers. In CVPR, 2022. 2,   
5

![](images/11.jpg)  
Figure 11. Additional selected samples from our ${ \bf 5 1 2 } \times { \bf 5 1 2 }$ and $2 5 6 \times 2 5 6$ resolution DiT-XL/2 models. We use a classifier-free guidanc scale of 6.0 for the $5 1 2 \times 5 1 2$ model and 4.0 for the $2 5 6 \times 2 5 6$ model. Both models use the ft-EMA VAE decoder.

# A. Additional Implementation Details

We include detailed information about all of our DiT models in Table 4, including both $2 5 6 \times 2 5 6$ and $5 1 2 \times 5 1 2$ models. In Figure 13, we report DiT training loss curves. Finally, we also include Gflop counts for DDPM U-Net models from ADM and LDM in Table 6. DiT model details. To embed input timesteps, we use a 256-dimensional frequency embedding [9] followed by a two-layer MLP with dimensionality equal to the transformer's hidden size and SiLU activations. Each adaLN layer feeds the sum of the timestep and class embeddings into a SiLU nonlinearity and a linear layer with output neurons equal to either $4 \times$ (adaLN) or $6 \times$ (adaLN-Zero) the transformer's hidden size. We use GELU nonlinearities (approximated with tanh) in the core transformer [16]. Classifier-free guidance on a subset of channels. In our experiments using classifier-free guidance, we applied guidance only to the first three channels of the latents instead of all four channels. Upon investigating, we found that threechannel guidance and four-channel guidance give similar results (in terms of FID) when simply adjusting the scale factor. Specifically, three-channel guidance with a scale of $( 1 + x )$ appears reasonably well-approximated by fourchannel guidance with a scale of $( 1 + { \frac { 3 } { 4 } } x )$ (e.g., threechannel guidance with a scale of 1.5 gives an FID-50K of 2.27, and four-channel guidance with a scale of 1.375 gives an FID-50K of 2.20). It is somewhat interesting that applying guidance to a subset of elements can still yield good performance, and we leave it to future work to explore this phenomenon further.

# B. Model Samples

We show samples from our two DiT-XL/2 models at $5 1 2 \times 5 1 2$ and $2 5 6 \times 2 5 6$ resolution trained for 3M and 7M steps, respectively. Figures 1 and 11 show selected samples from both models. Figures 14 through 33 show uncurated samples from the two models across a range of classifierfree guidance scales and input class labels (generated with 250 DDPM sampling steps and the ft-EMA VAE decoder). As with prior work using guidance, we observe that larger scales increase visual fidelity and decrease sample diversity.

<table><tr><td>Model</td><td>Image Resolution</td><td>Flops (G)</td><td>Params (M)</td><td>Training Steps (K)</td><td>Batch Size</td><td>Learning Rate</td><td>DiT Block</td><td>FID-50K (no guidance)</td></tr><tr><td>DiT-S/8</td><td>256 × 256</td><td>0.36</td><td>33</td><td>400</td><td>256</td><td>1 × 10−4</td><td>adaLN-Zero</td><td>153.60</td></tr><tr><td>DiT-S/4</td><td>256× 256</td><td>1.41</td><td>33</td><td>400</td><td>256</td><td>1 × 10−4</td><td>adaLN-Zero</td><td>100.41</td></tr><tr><td>DiT-S/2</td><td>256 × 256</td><td>6.06</td><td>33</td><td>400</td><td>256</td><td>1 × 10−4</td><td>adaLN-Zero</td><td>68.40</td></tr><tr><td>DiT-B/8</td><td>256 × 256</td><td>1.42</td><td>131</td><td>400</td><td>256</td><td>1 × 10−4</td><td>adaLN-Zero</td><td>122.74</td></tr><tr><td>DiT-B/4</td><td>256× 256</td><td>5.56</td><td>130</td><td>400</td><td>256</td><td>1 × 10−4</td><td>adaLN-Zero</td><td>68.38</td></tr><tr><td>DiT-B/2</td><td>256 × 256</td><td>23.01</td><td>130</td><td>400</td><td>256</td><td>1 × 10−4</td><td>adaLN-Zero</td><td>43.47</td></tr><tr><td>DiT-L/8</td><td>256 × 256</td><td>5.01</td><td>459</td><td>400</td><td>256</td><td>1 × 10−4</td><td>adaLN-Zero</td><td>118.87</td></tr><tr><td>DiT-L/4</td><td>256 × 256</td><td>19.70</td><td>458</td><td>400</td><td>256</td><td>1 × 10-4</td><td>adaLN-Zero</td><td>45.64</td></tr><tr><td>DiT-L/2</td><td>256 × 256</td><td>80.71</td><td>458</td><td>400</td><td>256</td><td>1 × 10−4</td><td>adaLN-Zero</td><td>23.33</td></tr><tr><td>DiT-XL/8</td><td>256 × 256</td><td>7.39</td><td>676</td><td>400</td><td>256</td><td>1 × 10−4</td><td>adaLN-Zero</td><td>106.41</td></tr><tr><td>DiT-XL/4</td><td>256× 256</td><td>29.05</td><td>675</td><td>400</td><td>256</td><td>1 × 10−4</td><td>adaLN-Zero</td><td>43.01</td></tr><tr><td>DiT-XL/2</td><td>256× 256</td><td>118.64</td><td>675</td><td>400</td><td>256</td><td>1 × 10−4</td><td>adaLN-Zero</td><td>19.47</td></tr><tr><td>DiT-XL/2</td><td>256 × 256</td><td>119.37</td><td>449</td><td>400</td><td>256</td><td>1 × 10−4</td><td>in-context</td><td>35.24</td></tr><tr><td>DiT-XL/2</td><td>256 × 256</td><td>137.62</td><td>598</td><td>400</td><td>256</td><td>1 × 10−4</td><td>cross-attention</td><td>26.14</td></tr><tr><td>DiT-XL/2</td><td>256 × 256</td><td>118.56</td><td>600</td><td>400</td><td>256</td><td>1 × 10−4</td><td>adaLN</td><td>25.21</td></tr><tr><td>DiT-XL/2</td><td>256 × 256</td><td>118.64</td><td>675</td><td>2352</td><td>256</td><td>1 × 10−4</td><td>adaLN-Zero</td><td>10.67</td></tr><tr><td>DiT-XL/2</td><td>256× 256</td><td>118.64</td><td>675</td><td>7000</td><td>256</td><td>1 × 10−4</td><td>adaLN-Zero</td><td>9.62</td></tr><tr><td>DiT-XL/2</td><td>512 × 512</td><td>524.60</td><td>675</td><td>1301</td><td>256</td><td>1 × 10−4</td><td>adaLN-Zero</td><td>13.78</td></tr><tr><td>DiT-XL/2</td><td>512 × 512</td><td>524.60</td><td>675</td><td>3000</td><td>256</td><td>1 × 10−4</td><td>adaLN-Zero</td><td>11.93</td></tr></table>

T encoder and decoder. For both the $2 5 6 \times 2 5 6$ and $5 1 2 \times 5 1 2$ DT-XL/2 models, we never observed FID saturate and continued training them as long as possible. Numbers reported in this table use the ft-MSE VAE decoder.

# C. Additional Scaling Results

Impact of scaling on metrics beyond FID. In Figure 12, we show the effects of DiT scale on a suite of evaluation metrics—FID, sFID, Inception Score, Precision and Recall. We find that our FID-driven analysis in the main paper generalizes to the other metrics—across every metric, scaled-up DiT models are more compute-efficient and model Gflops are highly-correlated with performance. In particular, Inception Score and Precision benefit heavily from increased model scale. Impact of scaling on training loss. We also examine the impact of scale on training loss in Figure 13. Increasing DiT model Gflops (via transformer size or number of input tokens) causes the training loss to decrease more rapidly and saturate at a lower value. This phenomenon is consistent with trends observed with language models, where scaledup transformers demonstrate both improved loss curves as well as improved performance on downstream evaluation suites [26].

# D. VAE Decoder Ablations

We used off-the-shelf, pre-trained VAEs across our experiments. The VAE models (ft-MSE and ft-EMA) are finetuned versions of the original LDM "f8" model (only the decoder weights are fine-tuned). We monitored metrics for our scaling analysis in Section 5 using the ft-MSE decoder, and we used the ft-EMA decoder for our final metrics reported in Tables 2 and 3. In this section, we ablate three different choices of the VAE decoder; the original one used by LDM and the two fine-tuned decoders used by Stable Diffusion. Because the encoders are identical across models, the decoders can be swapped-in without retraining the diffusion model. Table 5 shows results; XL/2 continues to outperform all prior diffusion models when using the LDM decoder.

Table 5. Decoder ablation. We tested different pre-trained VAE decoder weights available at https : / /huggingface. co/ stabilityai/sd-vae-ft-mse. Different pre-trained decoder weights yield comparable results on ImageNet $2 5 6 \times 2 5 6$ .   

<table><tr><td colspan="6">Class-Conditional ImageNet 256× 256, DiT-XL/2-G (cfg=1.5)</td></tr><tr><td>Decoder</td><td>FID↓</td><td>sFID↓</td><td>IS↑</td><td>Precision↑</td><td>Recall↑</td></tr><tr><td>original</td><td>2.46</td><td>5.18</td><td>271.56</td><td>0.82</td><td>0.57</td></tr><tr><td>ft-MSE</td><td>2.30</td><td>4.73</td><td>276.09</td><td>0.83</td><td>0.57</td></tr><tr><td>ft-EMA</td><td>2.27</td><td>4.60</td><td>278.24</td><td>0.83</td><td>0.57</td></tr></table>

Table 6. Gflop counts for baseline diffusion models that use UNet backbones. Note that we only count Flops for DDPM components.   

<table><tr><td colspan="5">Diffusion U-Net Model Complexities</td></tr><tr><td>Model</td><td>Image Resolution</td><td>Base Flops (G)</td><td>Upsampler Flops (G)</td><td>Total Flops (G)</td></tr><tr><td>ADM</td><td>128 × 128</td><td>307</td><td></td><td>307</td></tr><tr><td>ADM</td><td>256 × 256</td><td>1120</td><td></td><td>1120</td></tr><tr><td>ADM</td><td>512 × 512</td><td>1983</td><td>-</td><td>1983</td></tr><tr><td>ADM-U</td><td>256 × 256</td><td>110</td><td>632</td><td>742</td></tr><tr><td>ADM-U</td><td>512 × 512</td><td>307</td><td>2506</td><td>2813</td></tr><tr><td>LDM-4</td><td>256 × 256</td><td>104</td><td>-</td><td>104</td></tr><tr><td>LDM-8</td><td>256 × 256</td><td>57</td><td>-</td><td>57</td></tr></table>

![](images/12.jpg)

![](images/13.jpg)  
mean-squared error and $\mathcal { D } _ { K L }$ ). We also highlight early training behavior. Note that scaled-up DiT models exhibit lower training losses.

![](images/14.jpg)  
Figure 14. Uncurated $5 1 2 \times 5 1 2$ DiT-XL/2 samples. Classifier-free guidance scale $= 4 . 0$ Class label $=$ "arctic wolf" (270)

![](images/15.jpg)  
Figure 15. Uncurated $5 1 2 \times 5 1 2$ DiT-XL/2 samples. Classifier-free guidance scale $= 4 . 0$ Class label $=$ "volcano" (980)

![](images/16.jpg)  
Figure 16. Uncurated $5 1 2 \times 5 1 2$ DiT-XL/2 samples. Classifier-free guidance scale $= 4 . 0$ Class label $=$ "husky" (250)

![](images/17.jpg)  
Figure 17. Uncurated $5 1 2 \times 5 1 2$ DiT-XL/2 samples. Classifier-free guidance scale $= 4 . 0$ Class label $=$ "sulphur-crested cockatoo" (89)

![](images/18.jpg)  
Figure 18. Uncurated $5 1 2 \times 5 1 2$ DiT-XL/2 samples. Classifier-free guidance scale $= 4 . 0$ Class label $=$ "cliff drop-off" (972)

![](images/19.jpg)  
Figure 19. Uncurated $5 1 2 \times 5 1 2$ DiT-XL/2 samples. Classifier-free guidance scale $= 4 . 0$ Class label $=$ "balloon" (417)

![](images/20.jpg)  
Figure 20. Uncurated $5 1 2 \times 5 1 2$ DiT-XL/2 samples. Classifier-free guidance scale $= 4 . 0$ Class label $=$ "lion" (291)

![](images/21.jpg)  
Figure 21. Uncurated $5 1 2 \times 5 1 2$ DiT-XL/2 samples. Classifier-free guidance scale $= 4 . 0$ Class label $=$ "otter" (360)

![](images/22.jpg)  
Figure 22. Uncurated $5 1 2 \times 5 1 2$ DiT-XL/2 samples. Classifier-free guidance scale $= 2 . 0$ Class label $=$ "red panda" (387)

![](images/23.jpg)  
Figure 23. Uncurated $5 1 2 \times 5 1 2$ DiT-XL/2 samples. Classifier-free guidance scale $= 2 . 0$ Class label $=$ "panda" (388)

![](images/24.jpg)  
Figure 24. Uncurated $5 1 2 \times 5 1 2$ DiT-XL/2 samples. Classifier-free guidance scale $= 1 . 5$ Class label $=$ "coral reef" (973)

![](images/25.jpg)  
Figure 25. Uncurated $5 1 2 \times 5 1 2$ DiT-XL/2 samples. Classifier-free guidance scale $= 1 . 5$ Class label $=$ "macaw" (88)

![](images/26.jpg)  
Figure 26. Uncurated $2 5 6 \times 2 5 6$ DiT-XL/2 samples. Classifier-free guidance scale $= 4 . 0$ Class label $=$ "macaw" (88)

![](images/27.jpg)  
Figure 27. Uncurated $2 5 6 \times 2 5 6$ DiT-XL/2 samples. Classifier-free guidance scale $= 4 . 0$ Class label $=$ "dog sled" (537)

![](images/28.jpg)  
Figure 28. Uncurated $2 5 6 \times 2 5 6$ DiT-XL/2 samples. Classifier-free guidance scale $= 4 . 0$ Class label $=$ "arctic fox" (279)

![](images/29.jpg)  
Figure 29. Uncurated $2 5 6 \times 2 5 6$ DiT-XL/2 samples. Classifier-free guidance scale $= 4 . 0$ Class label $=$ "loggerhead sea turtle" (33)

![](images/30.jpg)  
Figure 30. Uncurated $2 5 6 \times 2 5 6$ DiT-XL/2 samples. Classifier-free guidance scale $= 2 . 0$ Class label $=$ "golden retriever" (207)

![](images/31.jpg)  
Figure 31. Uncurated $2 5 6 \times 2 5 6$ DiT-XL/2 samples. Classifier-free guidance scale $= 2 . 0$ Class label $=$ "lake shore" (975)

![](images/32.jpg)  
Figure 32. Uncurated $2 5 6 \times 2 5 6$ DiT-XL/2 samples. Classifier-free guidance scale $= 1 . 5$ Class label $=$ "space shuttle" (812)

![](images/33.jpg)  
Figure 33. Uncurated $2 5 6 \times 2 5 6$ DiT-XL/2 samples. Classifier-free guidance scale $= 1 . 5$ Class label $=$ "ice cream" (928)