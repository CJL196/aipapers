# 1. 论文基本信息

## 1.1. 标题
MemFlow: Flowing Adaptive Memory for Consistent and Efficient Long Video Narratives
(MemFlow：用于一致且高效的长视频叙事的流动自适应记忆)

## 1.2. 作者
Sihui Ji, Xi Chen, Shuai Yang, Xin Tao, Pengfei Wan, Hengshuang Zhao。

作者隶属于香港大学 (HKU)、快手科技 Kling 团队 (Kling Team, Kuaishou Technology) 以及香港科技大学（广州）(HKUST(GZ))。其中，Kling 团队是知名视频生成模型 Kling 的开发团队，表明该研究具有深厚的工业界背景和实践基础。

## 1.3. 发表期刊/会议
论文发布于 arXiv，这是一个收录科学论文预印本的平台。截至当前分析时间，该论文尚未在同行评审的会议或期刊上正式发表。arXiv 上的论文可以使研究成果被快速分享，但未经同行评审，其结论的可靠性需要读者审慎评估。

## 1.4. 发表年份
根据论文元数据，发布时间为 2025 年 12 月 16 日。这显然是一个未来的日期，表明该论文 ID (`2512.14699`) 可能是一个占位符或录入错误。然而，我们将基于提供的论文内容进行分析，并将其视为一篇预印本论文。

## 1.5. 摘要
流式视频生成的核心挑战是在长上下文中保持内容的一致性，这对记忆设计提出了很高的要求。大多数现有解决方案通过预定义的策略压缩历史帧来维护记忆。然而，不同的待生成视频块应该参考不同的历史线索，这很难用固定策略来满足。

在这项工作中，我们提出了 `MemFlow` 来解决这个问题。具体来说，在生成下一个视频块之前，我们通过使用该块的文本提示来检索最相关的历史帧，从而动态地更新记忆库。这种设计使得即使在未来的帧中出现新事件或场景切换，也能保持叙事的连贯性。此外，在生成过程中，我们只激活记忆库中与注意力层中每个查询最相关的词元 (token)，这有效地保证了生成效率。通过这种方式，`MemFlow` 实现了出色的长上下文一致性，而计算负担可忽略不计（与无记忆的基线相比，速度降低了 7.9%），并保持了与任何带有 KV 缓存的流式视频生成模型的兼容性。

## 1.6. 原文链接
- **原文链接:** https://arxiv.org/abs/2512.14699
- **PDF 链接:** https://arxiv.org/pdf/2512.14699v1.pdf
- **发布状态:** 预印本 (Preprint)。

# 2. 整体概括

## 2.1. 研究背景与动机
- **核心问题:** 当前的视频生成模型在生成**长视频**时，难以保持内容（如角色、场景、物体风格）的**长期一致性**。尤其是在<strong>交互式流生成 (interactive streaming generation)</strong> 场景下，用户会不断输入新的文本提示来引导视频叙事，这使得维持一致性变得更加困难。

- **问题重要性与挑战:**
    1.  **计算瓶颈:** 像 `DiT` (Diffusion Transformer) 这样的高质量模型，其注意力机制的计算成本随视频长度二次方增长，导致硬件资源（如 GPU 内存）无法支撑长视频的直接生成。
    2.  **错误累积:** <strong>自回归 (Autoregressive, AR)</strong> 方法将长视频分解为一系列短片顺序生成，虽然解决了计算瓶颈，但容易出现“漂移”现象，即微小的生成错误会随着时间不断累积，导致后续内容与初始内容不一致。
    3.  <strong>记忆机制的局限性 (Gap):</strong> 现有的记忆机制通常是**静态的**或**预定义的**。例如，有些方法只把第一帧作为记忆，有些则用固定的压缩算法来存储历史。这些“一刀切”的策略无法智能地应对变化的叙事需求。当新提示引入新角色或场景切换时，模型不知道应该参考历史中的哪些具体内容来保持一致性，哪些内容又应该被忽略。

- **本文切入点:** 论文的创新思路是让记忆变得<strong>“自适应 (adaptive)”</strong>和<strong>“流动 (flowing)”</strong>。`MemFlow` 提出，在生成每一个新的视频片段前，不应盲目地使用所有或固定的历史信息，而应该利用**当前新的文本提示**作为“查询”，主动地从历史帧中<strong>检索 (retrieve)</strong>出最相关的内容。这种“按需索取”的记忆机制，使得模型能为当前叙事任务精确地找到最有用的历史参考。

## 2.2. 核心贡献/主要发现
- **核心贡献:**
    1.  **提出了 `MemFlow` 框架:** 一种新颖的、兼容现有流式生成模型的记忆机制，旨在解决长视频的一致性和效率问题。
    2.  <strong>设计了叙事自适应记忆 (Narrative Adaptive Memory, NAM):</strong> 这是 `MemFlow` 的核心。它能够根据即将生成的视频内容的文本提示，动态地从历史帧中检索最相关的视觉信息来更新记忆库，从而实现智能化的上下文管理。
    3.  <strong>提出了稀疏记忆激活 (Sparse Memory Activation, SMA):</strong> 这是一种高效的注意力计算策略。在生成时，它只“激活”记忆库中最相关的部分参与计算，从而在不牺牲质量的前提下，极大地降低了额外记忆带来的计算开销。

- **主要发现:**
    1.  **卓越的一致性:** `MemFlow` 能有效维持长视频（例如60秒）的叙事连贯性，即使在多次更换提示、引入新角色或场景切换的复杂情况下，也能保持主体人物和背景的一致。
    2.  **高效的性能:** `MemFlow` 在实现高质量记忆的同时，只带来了极小的性能损耗。与完全不使用记忆的基线模型相比，其生成速度仅下降 7.9%，实现了质量与效率的平衡。
    3.  **强大的兼容性:** 该框架可以即插即用地集成到任何使用 <strong>KV 缓存 (KV cache)</strong> 的自回归视频生成模型中，具有很好的通用性。

# 3. 预备知识与相关工作

## 3.1. 基础概念
### 3.1.1. 扩散模型 (Diffusion Models)
扩散模型是一类强大的生成模型。其基本思想包含两个过程：
1.  <strong>前向过程 (Forward Process):</strong> 从一张清晰的图像（或视频帧）开始，逐步地、迭代地向其添加少量高斯噪声，直到它完全变成纯粹的噪声。这个过程是固定的、不可学习的。
2.  <strong>反向过程 (Reverse Process):</strong> 模型学习如何逆转上述过程。它从一个随机噪声开始，逐步地、迭代地去除噪声，最终恢复出一张清晰的、符合数据分布的图像。通过在去噪过程中引入文本等条件，模型可以生成与条件相符的内容。

### 3.1.2. 扩散变换器 (Diffusion Transformer, DiT)
`DiT` 是将强大的 <strong>变换器 (Transformer)</strong> 架构应用于扩散模型的去噪网络中。传统的去噪网络多采用 U-Net 结构，而 `DiT` 将带噪声的图像块（或视频帧块）视为词元 (token)，并使用 Transformer 的自注意力机制来学习它们之间的依赖关系，从而实现更高质量的生成。

### 3.1.3. 自回归生成 (Autoregressive Generation)
自回归是一种序列生成范式，其核心思想是“下一个依赖于所有之前”。在生成序列 $x = (x_1, x_2, ..., x_T)$ 时，每个元素 $x_t$ 的生成都以之前的所有元素 $(x_1, ..., x_{t-1})$ 为条件。在视频领域，这意味着将长视频分解为一系列短视频块（chunks），然后一块接一块地生成，每一块的生成都以上一块（或前几块）为条件。

### 3.1.4. KV 缓存 (Key-Value Cache)
`KV 缓存` 是 Transformer 模型在进行自回归推理时的一种关键优化技术。在 Transformer 的自注意力层中，每个词元 (token) 都会生成一个查询 (Query, Q)、一个键 (Key, K) 和一个值 (Value, V) 向量。当生成第 $t$ 个词元时，它的 Q 需要与前面所有 `1` 到 $t$ 个词元的 K 和 V 进行注意力计算。
`KV 缓存` 的作用是，在生成完第 `t-1` 个词元后，将所有 `1` 到 `t-1` 个词元的 K 和 V 向量存储起来。这样，在生成第 $t$ 个词元时，就无需重新计算这些历史词元的 K 和 V，只需计算当前词元的 Q、K、V，然后将 Q 与缓存中所有的 K、V 进行计算即可。这大大提高了生成效率。本文的记忆库正是基于存储历史帧的 `KV 缓存` 构建的。

## 3.2. 前人工作
论文将长视频生成的相关工作分为三类，并将视频生成中的记忆机制作为另一个重要领域进行回顾。

### 3.2.1. 长视频生成方法
1.  <strong>自回归-扩散混合方法 (Autoregressive-diffusion hybrid):</strong>
    *   这类方法通过迭代预测后续帧或视频块来生成长视频。代表工作有 `CausVid`、`Self Forcing`、`MAGI-1` 等。
    *   它们是流式生成的基础，但普遍面临错误累积和长期一致性差的问题。

2.  <strong>多阶段方法 (Multistage methods):</strong>
    *   这类方法将长视频生成分解为多个独立阶段。例如，先生成一系列连贯的关键帧，再通过视频插值技术填充中间帧；或者先生成一系列提示，再用文生视频模型逐个生成视频片段。
    *   其主要局限在于各片段是孤立生成的，导致整体时间连贯性不足。

3.  <strong>高效架构方法 (Efficient architectures):</strong>
    *   这类方法通过改进模型架构来降低计算成本，例如使用线性注意力 (`LaCT`) 或对视频片段进行词元压缩 (`TokensGen`)。`Mixture of Contexts` 动态选择相关上下文进行注意力计算。
    *   这些方法通常为了效率而牺牲了一部分生成质量。

### 3.2.2. 视频生成中的记忆机制
1.  **基于几何先验的方法:**
    *   这类方法主要用于与相机运动相关的视频生成。例如，`Worldmem` 和 `Context as memory` 根据相机视场 (FOV) 的重叠来检索记忆。
    *   它们严重依赖于空间先验信息（如相机位姿），通用性较差。

2.  **基于上下文压缩的方法:**
    *   这是更通用的方法。例如，`FramePack` 将输入帧压缩成固定大小的上下文。`FAR` 和 `StreamingT2V` 结合长短期记忆。
    *   这些方法虽然保留了历史信息，但通常缺乏**自适应检索**能力，难以根据当前生成任务的特定需求，动态地提供最相关的历史信息。

## 3.3. 技术演进
长视频生成技术的发展脉络大致如下：
1.  **短视频生成：** 以 `Sora`、`Kling` 等基于 `DiT` 的模型为代表，实现了高质量的短视频生成，但受限于计算资源无法直接扩展到长视频。
2.  **基于自回归的扩展：** 通过将长视频分解为短片，使用自回归方式顺序生成，如 `Self Forcing`。这解决了计算瓶颈，但引入了**一致性**问题。
3.  **引入朴素记忆：** 为解决一致性问题，研究者开始引入记忆机制。早期方法比较简单，如 `LongLive` 仅保留第一个视频块作为记忆（称为 `Frame Sink`），或 `FramePack` 对历史进行固定压缩。这些方法是**静态**的。
4.  <strong>引入自适应记忆（本文工作）：</strong> `MemFlow` 标志着一个重要的进步。它不再被动地接受历史信息，而是**主动地、智能地**根据当前任务（即新的文本提示）去**检索**和**筛选**历史记忆。这使得记忆管理从“静态存储”演变为“动态交互”。

## 3.4. 差异化分析
`MemFlow` 与以往工作的核心区别在于其**记忆的动态性和适应性**：
- <strong>相对于 `LongLive` (Frame Sink):</strong> `LongLive` 只保留第一个视频块作为全局参考，当视频叙事发生重大变化（如主角更换）时，这个固定的记忆就变得无关紧要甚至有害。而 `MemFlow` 的记忆库是流动的，能根据新提示引入与新主角相关的历史帧，保持叙事连贯。
- <strong>相对于 `FramePack` (固定压缩):</strong> `FramePack` 等方法使用固定的压缩策略来打包历史信息。这种策略是“一视同仁”的，可能会丢弃对未来某个特定场景至关重要的细节。而 `MemFlow` 的 `NAM` 机制通过**语义检索**，确保了与当前提示最相关的信息被优先保留。
- <strong>相对于 <code>Mixture of Contexts</code>:</strong> `Mixture of Contexts` 也是一种动态选择上下文的方法，但 `MemFlow` 的独特之处在于其 `NAM` 机制是基于**未来块的文本提示**来检索历史视觉帧，专门为交互式叙事转换设计。同时，`SMA` 机制在生成过程中根据**当前视觉查询**进一步筛选记忆，实现了从记忆更新到记忆使用的双重动态优化。

# 4. 方法论
`MemFlow` 的核心是将一个新颖的动态记忆库集成到一个流式视频生成框架中。其方法由两部分组成：<strong>叙事自适应记忆 (NAM)</strong> 用于更新记忆，<strong>稀疏记忆激活 (SMA)</strong> 用于高效使用记忆。

下面是 `MemFlow` 框架的示意图（原文 Figure 2），展示了其整体流程：

![该图像是示意图，展示了MemFlow的叙事自适应记忆机制。通过动态更新记忆库以检索与当前提示相关的历史帧，该方法实现了高效的记忆利用与生成效率。此外，图中显示了自回归生成模型中的记忆选择与更新过程。](images/2.jpg)
*该图像是示意图，展示了MemFlow的叙事自适应记忆机制。通过动态更新记忆库以检索与当前提示相关的历史帧，该方法实现了高效的记忆利用与生成效率。此外，图中显示了自回归生成模型中的记忆选择与更新过程。*

## 4.1. 方法原理
`MemFlow` 的核心直觉是：为了在生成长视频时保持一致性，模型在生成新的视频片段时，需要参考历史中与之**语义相关**的片段。例如，当新提示为“一个穿着红色毛衣的女人在弹吉他”时，如果历史片段中曾出现过“一个穿着红色毛衣的女人”，模型就应该重点关注那个片段以确保人物一致性。

`MemFlow` 通过以下设计实现了这一直觉：
1.  <strong>记忆库 (Memory Bank):</strong> 维护一个存储历史信息的记忆库，其中包含从过去生成的视频块中提取的 `KV 缓存`。
2.  <strong>记忆更新 (NAM):</strong> 在生成新视频块**之前**，根据新视频块的**文本提示**，从记忆库中检索出最相关的历史帧，并结合最新生成的视频块信息，形成一个新的、更新后的记忆库。
3.  <strong>记忆使用 (SMA):</strong> 在生成新视频块的**过程中**，对于当前正在处理的视觉查询，只从更新后的记忆库中挑选最相关的部分进行注意力计算，以节省算力。

## 4.2. 核心方法详解

### 4.2.1. 整体框架 (Overall Framework)
- **基线模型:** 论文基于一个自回归-扩散混合框架，该框架以视频块（chunk）为单位进行自回归生成。在生成第 $m$ 个视频块时，模型以其紧邻的前 $n$ 帧作为短期上下文。
- **记忆整合:** `MemFlow` 对基线模型进行了扩展。在注意力计算时，模型不仅关注当前的 $T$ 帧和局部的 $n$ 帧，还会关注记忆库中的 $B$ 帧。因此，注意力窗口从 $(n+T)$ 扩展到了 $(n+B+T)$。
- **训练机制:** 采用 `Self-Forcing` 范式进行训练。在“流式长微调 (streaming long-tuning)”过程中，模型不断生成新的 5 秒视频片段，并由一个预训练的“教师”模型提供监督。`NAM` 和 `SMA` 机制被整合到这个训练过程中，使模型学会在推理时如何有效地管理和利用其记忆。

### 4.2.2. 叙事自适应记忆 (Narrative Adaptive Memory, NAM)
`NAM` 负责在每次生成迭代后动态地更新记忆库。这个过程包含两个关键步骤：<strong>语义检索 (Semantic Retrieval)</strong> 和 <strong>冗余移除 (Redundant Removal)</strong>。

#### 1. 语义检索 (Semantic Retrieval)
此步骤的目标是根据**下一个视频块的文本提示**，从现有记忆库中筛选出最重要的历史帧。

- **过程:**
    1.  假设当前记忆库中存储了来自过去 $b$ 个代表性帧的 `KV 缓存`。
    2.  获取即将生成的下一个视频块的文本提示，并从中提取文本查询向量 $Q_{\text{text}}^l$（在 Transformer 的第 $l$ 层）。
    3.  对于记忆库中的每一帧 $i$（其视觉键为 $K_{m,i}^l$），计算其与文本提示的语义相关性得分 $\mathcal{S}_{m,i}^l$。
- **公式:**
  该相关性得分的计算公式如下：
    $$
    \mathcal { S } _ { m , i } ^ { l } = \mathrm { A g g r e g a t e } \left( \mathrm { S o f t m a x } \left( \frac { Q _ { \mathrm { t e x t } } ^ { l } ( K _ { m , i } ^ { l } ) ^ { \top } } { \sqrt { d } } \right) \right)
    $$
- **符号解释:**
    *   $\mathcal{S}_{m,i}^l$: 在第 $m$ 次生成迭代、第 $l$ 层，第 $i$ 个记忆帧的最终语义相关性**标量分数**。
    *   $Q_{\text{text}}^l \in \mathbb{R}^{d}$: 来自**下一个文本提示**的文本查询向量。
    *   $K_{m,i}^l \in \mathbb{R}^{N \times d}$: 记忆库中第 $i$ 帧的视觉**键**张量，其中 $N$ 是该帧的词元数量，$d$ 是特征维度。
    *   $\frac{Q_{\text{text}}^l (K_{m,i}^l)^\top}{\sqrt{d}}$: 计算文本查询与该帧所有视觉键之间的缩放点积注意力分数。
    *   $\mathrm{Softmax}(\cdot)$: 对注意力分数进行归一化，得到权重。
    *   $\mathrm{Aggregate}(\cdot)$: 聚合函数，论文中指明为<strong>平均池化 (mean pooling)</strong>。它将所有视觉词元的权重聚合成一个单一的分数，代表整个帧与文本提示的相关性。
- **结果:** 根据计算出的分数 $\mathcal{S}_{m,i}^l$，选择分数最高的 `top-k` 帧作为最相关的历史内容予以保留。

#### 2. 冗余移除 (Redundant Removal)
此步骤的目标是高效地将**刚刚生成的视频块**的信息整合进记忆库。

- **过程:**
    *   论文提出一个高效的启发式方法：由于短视频块内部的帧之间具有很高的**时间冗余性**，因此可以用单个帧来代表整个视频块的核心视觉内容。
    *   具体地，模型只选择**上一个生成块的第一帧**的 `KV` 对，作为该块的紧凑<strong>原型 (prototype)</strong>。
- **最终更新:** 新的记忆库由两部分拼接而成：(1) 从旧记忆库中通过**语义检索**筛选出的 `top-k` 个历史帧；(2) 从最新生成的视频块中提取的**原型帧**。这个策略确保记忆库既包含与当前任务相关的长期记忆，也包含最新的短期记忆，同时保持了固定的大小，避免无限增长。

### 4.2.3. 稀疏记忆激活 (Sparse Memory Activation, SMA)
`SMA` 负责在生成新视频块的**过程中**，高效地利用记忆库，以平衡质量和效率。

- **原理:** 在注意力计算时，让当前帧的查询只与记忆库中**最相关**的一小部分帧进行交互，而不是全部。
- **过程:**
    1.  **计算描述符:**
        *   将当前正在生成的视频块的视觉查询 $Q_{\text{vis}}^l$ 通过平均池化压缩成一个单一的查询描述符 $\bar{q}_{\text{vis}} \in \mathbb{R}^{1 \times d}$。
        *   对记忆库中的每一帧 $j$，将其键 $K_j$ 也通过平均池化压缩成一个键描述符 $\bar{k}_j \in \mathbb{R}^{1 \times d}$。
    2.  **计算相关性:** 通过描述符的内积计算当前查询与每个记忆帧的相关性分数 $s_j$。
        $$
        s _ { j } = \bar { q } _ { \mathrm { v i s } } ^ { \top } \bar { k } _ { j } , \quad \mathrm { f o r } \quad j = 1 , \ldots , b
        $$
        其中 $b$ 是记忆库中的总帧数。
    3.  **选择 Top-k 帧:** 根据分数 $s_j$ 选出最相关的 `top-k` 帧。其索引集合 $\mathcal{T}_k$ 的选择公式为：
        $$
        \mathcal { T } _ { k } = \underset { I \subseteq \{ 1 , \dots , b \} , | I | = k } { \arg \operatorname* { m a x } } \sum _ { j \in I } s _ { j }
        $$
        这表示选择一个大小为 $k$ 的索引子集 $I$，使得该子集中所有帧的相关性分数之和最大。
    4.  **进行稀疏注意力计算:** 最后，注意力计算只在选定的 `top-k` 帧的 `KV` 对上进行。
        $$
        \mathrm { A t t n } ( Q _ { \mathrm { v i s } } ^ { l } , K _ { m } ^ { l } , V _ { m } ^ { l } ) \approx \mathrm { A t t n } ( Q _ { \mathrm { v i s } } ^ { l } , K _ { m , \mathcal { T } _ { k } } ^ { l } , V _ { m , \mathcal { T } _ { k } } ^ { l } )
        $$
        其中 $K_{m, \mathcal{T}_k}^l$ 和 $V_{m, \mathcal{T}_k}^l$ 是从由 $\mathcal{T}_k$ 索引的 `top-k` 帧中拼接而成的键和值张量。

通过 `SMA`，`MemFlow` 在利用长期记忆的同时，避免了巨大的计算开销，并能通过过滤不相关或错误的历史信息来减轻错误累积。

# 5. 实验设置

## 5.1. 数据集
- **多提示生成数据集:** 使用了 `LongLive` [35] 论文中构建的 `switch-prompt` 数据集。该数据集由 `Qwen2-72B-Instruct` [34] 模型生成，包含 100 组叙事脚本。每组脚本由 6 个连续的 10 秒提示组成，用于生成总长 60 秒的视频。这非常适合测试模型在动态提示下的叙事连贯性。
- **单提示生成数据集:** 使用了 `VBench` [16] 的官方提示集，用于评估模型在标准 5 秒和 30 秒单提示视频生成任务上的性能。

## 5.2. 评估指标
- **VBench-Long [17] 指标:**
    - `Quality Score`: 综合衡量生成视频的感知质量。
    - `Consistency Score`: 衡量视频中主体、背景等元素在长时间内的外观一致性。
    - `Aesthetic Score`: 衡量视频的视觉美学水平。
      这些指标通常由预训练的评估模型计算得出，分数越高代表性能越好。

- **CLIP Score:**
    1.  <strong>概念定义 (Conceptual Definition):</strong> `CLIP Score` 用于衡量生成的视频内容与输入文本提示之间的**语义一致性**。它利用 OpenAI 的 `CLIP` 模型强大的图文理解能力，将视频帧和文本提示映射到同一个特征空间，然后计算它们之间的相似度。分数越高，表示视频内容越符合文本描述。
    2.  <strong>数学公式 (Mathematical Formula):</strong> 对于一个视频 $V$（由一系列帧 $v_i$ 组成）和一个文本提示 $t$，`CLIP Score` 通常计算为所有帧与文本的平均相似度：
        $$
        \text{CLIP Score}(V, t) = \frac{1}{N} \sum_{i=1}^{N} \text{cosine\_similarity}(E_V(v_i), E_T(t)) \times 100
        $$
    3.  <strong>符号解释 (Symbol Explanation):</strong>
        *   $v_i$: 视频中的第 $i$ 帧。
        *   $t$: 输入的文本提示。
        *   $E_V(\cdot)$: `CLIP` 模型的图像编码器，将图像编码为特征向量。
        *   $E_T(\cdot)$: `CLIP` 模型的文本编码器，将文本编码为特征向量。
        *   $\text{cosine\_similarity}(\cdot, \cdot)$: 余弦相似度函数，衡量两个向量在方向上的接近程度。
        *   $N$: 视频的总帧数。

- <strong>吞吐量 (Throughput, FPS):</strong>
    1.  <strong>概念定义 (Conceptual Definition):</strong> `FPS` (Frames Per Second) 即每秒生成的帧数，是衡量模型**生成速度**的核心指标。`FPS` 越高，表示模型推理效率越高，越接近实时生成。
    2.  <strong>数学公式 (Mathematical Formula):</strong>
        $$
        \text{FPS} = \frac{\text{Total Number of Generated Frames}}{\text{Total Generation Time (in seconds)}}
        $$
    3.  <strong>符号解释 (Symbol Explanation):</strong>
        *   `Total Number of Generated Frames`: 在一次生成任务中总共生成的视频帧数。
        *   `Total Generation Time`: 完成这次生成任务所花费的总时间。

## 5.3. 对比基线
论文将 `MemFlow` 与一系列代表性的长视频生成模型进行了比较：
- **多提示生成对比:** `SkyReels-V2` [3], `Self Forcing` [15], `LongLive` [35], `FramePack` [42]。
- **单提示短视频对比:** `LTX-Video` [9], `Wan2.1` [29], `MAGI-1` [28], `CausVid` [39], `NOVA` [7], `Pyramid Flow` [19] 等。
  其中，`LongLive` [35] 是一个非常重要的基线，因为 `MemFlow` 的实现是建立在其框架之上，并对其记忆机制（`Frame Sink`）进行了直接的改进和对比。

# 6. 实验结果与分析

## 6.1. 核心结果分析

### 6.1.1. 多提示生成 (60秒)
该实验旨在验证 `MemFlow` 在处理动态叙事变化时的核心能力。

**以下是原文 Table 1 的结果：**

<table>
<thead>
<tr>
<th rowspan="2">Method</th>
<th rowspan="2">Quality Score ↑</th>
<th rowspan="2">Consistency Score ↑</th>
<th rowspan="2">Aesthetic Score ↑</th>
<th colspan="6">CLIP Score ↑</th>
</tr>
<tr>
<th>0-10 s</th>
<th>10-20 s</th>
<th>20-30 s</th>
<th>30-40 s</th>
<th>40-50 s</th>
<th>50-60 s</th>
</tr>
</thead>
<tbody>
<tr>
<td>SkyReels-V2 [3]</td>
<td>81.55</td>
<td>94.72</td>
<td>56.83</td>
<td>25.31</td>
<td>23.40</td>
<td>22.50</td>
<td>21.62</td>
<td>21.67</td>
<td>20.91</td>
</tr>
<tr>
<td>Self Forcing [15]</td>
<td>83.94</td>
<td>95.74</td>
<td>58.45</td>
<td>26.24</td>
<td>24.87</td>
<td>23.46</td>
<td>21.92</td>
<td>22.05</td>
<td>21.07</td>
</tr>
<tr>
<td>LongLive [35]</td>
<td>84.28</td>
<td>96.05</td>
<td>59.89</td>
<td>26.63</td>
<td>25.77</td>
<td>24.65</td>
<td>23.99</td>
<td>24.52</td>
<td>24.11</td>
</tr>
<tr>
<td>FramePack [15]</td>
<td>84.40</td>
<td>96.77</td>
<td>59.44</td>
<td>26.51</td>
<td>22.60</td>
<td>22.18</td>
<td>21.53</td>
<td>21.98</td>
<td>21.62</td>
</tr>
<tr>
<td>MeMFLOW</td>
<td>85.02</td>
<td>96.60</td>
<td>61.07</td>
<td>26.31</td>
<td>24.70</td>
<td>23.94</td>
<td>24.13</td>
<td>24.90</td>
<td>24.22</td>
</tr>
</tbody>
</table>

- **分析:**
    - **综合质量:** `MemFlow` 在 `Quality Score` (85.02) 和 `Aesthetic Score` (61.07) 上均取得最高分，表明其生成的视频整体质量和美学水平最佳，有效缓解了错误累积。
    - **一致性:** `MemFlow` 的 `Consistency Score` (96.60) 略低于 `FramePack` (96.77)，但论文指出 `FramePack` 的视频动态性较差，其高一致性可能是以牺牲内容变化为代价的。因此，`MemFlow` 在保持动态性的同时实现了极高的一致性。
    - **文本对齐:** 从 `CLIP Score` 随时间的变化可以看出，所有模型的得分都有下降趋势，这是长视频生成的普遍挑战。然而，`MemFlow` 在后半段（30-60s）的 `CLIP Score` 保持得相对稳定和领先，尤其是在 40-50s (24.90) 和 50-60s (24.22) 区间，这证明了 `NAM` 机制在处理连续的提示切换时，能更好地维持叙事连贯性和文本对齐。

      下图（原文 Figure 3）直观展示了 `MemFlow` 的优势。当提示切换时，`MemFlow` 能够正确地保持主体人物（“a woman in a casual sweater”）的一致性，而 `LongLive` 等基线模型则会引入新的人物，破坏了叙事。

      ![该图像是示意图，展示了不同视频生成模型在不同时间点的输出效果，包括SkyReels-V2、FramePack、Self-Forcing、LongLive和Ours。这些模型在12秒、24秒、36秒、48秒和60秒的生成效果可视化，展示了MemFlow在长视频叙事中的优势。](images/3.jpg)
      *该图像是示意图，展示了不同视频生成模型在不同时间点的输出效果，包括SkyReels-V2、FramePack、Self-Forcing、LongLive和Ours。这些模型在12秒、24秒、36秒、48秒和60秒的生成效果可视化，展示了MemFlow在长视频叙事中的优势。*

### 6.1.2. 单提示生成 (5秒 & 30秒)
这两个实验验证了 `MemFlow` 在标准视频生成任务上不仅没有性能下降，反而有所提升。

<strong>以下是原文 Table 2 (5秒视频) 和 Table 4 (30秒视频) 的结果：</strong>

**Table 2: 5秒短视频生成**

<table>
<thead>
<tr>
<th rowspan="2">Model</th>
<th rowspan="2">#Params</th>
<th rowspan="2">Resolution</th>
<th rowspan="2">Throughput (FPS) ↑</th>
<th colspan="3">Evaluation scores ↑</th>
</tr>
<tr>
<th>Total</th>
<th>Quality</th>
<th>Semantic</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="7">Diffusion models</td>
</tr>
<tr>
<td>LTX-Video [9]</td>
<td>1.9B</td>
<td>768×512</td>
<td>8.98</td>
<td>80.00</td>
<td>82.30</td>
<td>70.79</td>
</tr>
<tr>
<td>Wan2.1 [29]</td>
<td>1.3B</td>
<td>832×480</td>
<td>0.78</td>
<td>84.26</td>
<td>85.30</td>
<td>80.09</td>
</tr>
<tr>
<td colspan="7">Autoregressive models</td>
</tr>
<tr>
<td>SkyReels-V2 [3]</td>
<td>1.3B</td>
<td>960×540</td>
<td>0.49</td>
<td>82.67</td>
<td>84.70</td>
<td>74.53</td>
</tr>
<tr>
<td>MAGI-1 [28]</td>
<td>4.5B</td>
<td>832×480</td>
<td>0.19</td>
<td>79.18</td>
<td>82.04</td>
<td>67.74</td>
</tr>
<tr>
<td>CausVid [39]</td>
<td>1.3B</td>
<td>832×480</td>
<td>17.0</td>
<td>81.20</td>
<td>84.05</td>
<td>69.80</td>
</tr>
<tr>
<td>NOVA [7]</td>
<td>0.6B</td>
<td>768×480</td>
<td>0.88</td>
<td>80.12</td>
<td>80.39</td>
<td>79.05</td>
</tr>
<tr>
<td>Pyramid Flow [19]</td>
<td>2B</td>
<td>640×384</td>
<td>6.7</td>
<td>81.72</td>
<td>84.74</td>
<td>69.62</td>
</tr>
<tr>
<td>Self Forcing, chunk-wise [15]</td>
<td>1.3B</td>
<td>832×480</td>
<td>17.0</td>
<td>84.31</td>
<td>85.07</td>
<td>81.28</td>
</tr>
<tr>
<td>Self Forcing, frame-wise [15]</td>
<td>1.3B</td>
<td>832×480</td>
<td>8.9</td>
<td>84.26</td>
<td>85.25</td>
<td>80.30</td>
</tr>
<tr>
<td>LongLive [35]</td>
<td>1.3B</td>
<td>832×480</td>
<td>20.3†</td>
<td>84.87</td>
<td>86.97</td>
<td>76.47</td>
</tr>
<tr>
<td>MeMFLOW</td>
<td>1.3B</td>
<td>832×480</td>
<td>18.7</td>
<td>85.14</td>
<td>85.95</td>
<td>81.90</td>
</tr>
</tbody>
</table>

**Table 4: 30秒长视频生成**

| Model | Total Score ↑ | Quality Score ↑ | Semantic Score ↑ | Throughput (FPS) ↑ |
| :--- | :--- | :--- | :--- | :--- |
| SkyReels-V2 [3] | 75.29 | 80.77 | 53.37 | 0.49 |
| FramePack [42] | 81.95 | 83.61 | 75.32 | 0.92 |
| Self Forcing [15] | 81.59 | 83.82 | 72.70 | 17.0 |
| LongLive [35] | 83.52 | 85.44 | 75.82 | 20.3 |
| MEMFLOW | 84.51 | 85.92 | 78.87 | 18.7 |

- **分析:**
    - 在 5 秒短视频中，`MemFlow` 的 `Total Score` (85.14) 和 `Semantic Score` (81.90) 均达到最高，证明其记忆机制甚至对短视频的文本对齐也有帮助。其速度 (18.7 FPS) 虽略低于 `LongLive` (20.3 FPS)，但仍远超其他大部分模型，保持了高效性。
    - 在 30 秒长视频中，`MemFlow` 的优势更加明显，所有指标（`Total`, `Quality`, `Semantic`）均全面超越所有基线模型。这有力地证明了其动态记忆机制在处理更长上下文时的优越性。

## 6.2. 消融实验/参数分析

### 6.2.1. 记忆机制消融实验
该实验旨在验证 `NAM` 和 `SMA` 两个核心组件的有效性。

**以下是原文 Table 3 的结果：**

<table>
<thead>
<tr>
<th rowspan="2">Memory Mechanism</th>
<th rowspan="2">Subject Consistency ↑</th>
<th rowspan="2">Background Consistency ↑</th>
<th rowspan="2">Throughput (FPS) ↑</th>
<th colspan="6">CLIP Score ↑</th>
</tr>
<tr>
<th>0-10 s</th>
<th>10-20 s</th>
<th>20-30 s</th>
<th>30-40 s</th>
<th>40-50 s</th>
<th>50-60 s</th>
</tr>
</thead>
<tbody>
<tr>
<td>w/o Memory</td>
<td>94.41</td>
<td>95.15</td>
<td>23.5</td>
<td>26.74</td>
<td>25.10</td>
<td>24.60</td>
<td>23.61</td>
<td>24.23</td>
<td>24.14</td>
</tr>
<tr>
<td>Frame Sink [35]</td>
<td>97.66</td>
<td>96.20</td>
<td>20.3</td>
<td>26.63</td>
<td>25.77</td>
<td>24.65</td>
<td>23.99</td>
<td>24.52</td>
<td>24.11</td>
</tr>
<tr>
<td>NAM+SMA</td>
<td>98.01</td>
<td>96.70</td>
<td>18.7</td>
<td>26.31</td>
<td>24.70</td>
<td>23.94</td>
<td>24.13</td>
<td>24.90</td>
<td>24.22</td>
</tr>
<tr>
<td>NAM</td>
<td>98.05</td>
<td>96.57</td>
<td>17.6</td>
<td>26.50</td>
<td>25.30</td>
<td>24.42</td>
<td>24.23</td>
<td>24.96</td>
<td>24.28</td>
</tr>
</tbody>
</table>

- **分析:**
    - **`NAM` 的作用:** 对比 `w/o Memory` (无记忆) 和 `Frame Sink` (LongLive的静态记忆)，`NAM` (使用动态记忆但无稀疏激活) 在主体和背景一致性上都取得了最高分 (98.05/96.57)，同时 `CLIP Score` 在视频后半段表现最佳。这证明了 `NAM` 的动态语义检索机制是提升一致性的关键。
    - **`SMA` 的作用:** 对比 `NAM` 和 $NAM+SMA$ (完整模型)，$NAM+SMA$ 在各项指标上与 `NAM` 非常接近，性能几乎没有损失，但吞吐量从 17.6 FPS 提升到了 18.7 FPS。这证明 `SMA` 成功地在保持高质量记忆的同时，显著提升了计算效率。
    - 整体来看，`NAM` 负责“做得好”，`SMA` 负责“做得快”，二者结合实现了高质量与高效率的平衡。

### 6.2.2. 记忆容量参数分析
该实验探究了 `NAM` 中记忆库容量 $b$（即存储的历史帧数量）对性能的影响。

下图（原文 Figure 5）展示了不同容量下的 `CLIP Score` 变化：

![Figure 5. Quantitative analysis of different memory capacity under multi-prompt 60-second setting. "w/o Memory" means only attending to the local attention window, "Frame Sink" refers to keeping KV cache from the first chunk as memory \[35\], "NAM" adopts the whole memory bank including $^ { b }$ latent frames.](images/5.jpg)
*该图像是一个图表，展示了在多提示60秒设置下不同记忆容量的定量分析。图中对比了"None"、"Frame Sink"与不同参数$b$值的NAM（$b=3, 6, 9$）在不同时间段（0-10s, 10-20s, 20-30s等）的CLIP得分变化。*

- **分析:**
    - 图表显示，更大的记忆容量并不总能带来更好的性能。当 $b=6$ 和 $b=9$ 时，模型的性能反而出现了不稳定甚至下降的情况。
    - 论文推测，这是因为过大的记忆容量（全局上下文）会压倒局部上下文（紧邻的前几帧）的作用，破坏了模型对短期叙事流的建模。注意力机制被过多的历史信息“分心”，导致性能波动。
    - 实验发现，当 $b=3$ 时（即记忆库大小是局部上下文窗口的一半），模型性能最为稳定，并且在语义一致性上取得了比基线 (`Frame Sink`) 更好的效果。因此，论文最终选择了 $b=3$ 作为最佳配置。这揭示了在记忆设计中，全局上下文和局部上下文之间需要一个精细的平衡。

# 7. 总结与思考

## 7.1. 结论总结
本论文提出了 `MemFlow`，一个为交互式长视频生成设计的、兼具一致性和高效率的流动自适应记忆框架。其核心贡献是通过两个创新组件实现的：
1.  <strong>叙事自适应记忆 (NAM):</strong> 它根据未来视频块的文本提示，从历史中动态检索语义相关的视觉上下文来更新记忆库，从而巧妙地解决了在叙事切换时保持内容一致的难题。
2.  <strong>稀疏记忆激活 (SMA):</strong> 它通过在生成时只激活与当前查询最相关的记忆部分，有效平衡了记忆质量与计算效率，使得 `MemFlow` 在实现卓越一致性的同时，计算开销极小。

    实验证明，`MemFlow` 在多提示和单提示的长视频生成任务上均取得了最先进的性能，尤其是在维持长期叙事连贯性和文本对齐方面表现突出，同时保持了接近实时的生成速度 (18.7 FPS)。

## 7.2. 局限性与未来工作
尽管论文取得了显著成果，但仍存在一些潜在的局限性和值得探索的方向（论文未明确指出，为个人分析）：
- **记忆原型过于简化:** `NAM` 中“冗余移除”步骤将一个视频块简化为第一帧的 `KV 缓存`。这个启发式方法虽然高效，但可能会丢失块内后半部分出现的关键信息。未来的工作可以探索更复杂的视频块压缩方法，如学习一个压缩器，在效率和信息保真度之间取得更好的平衡。
- **检索维度的单一性:** `NAM` 的检索完全基于文本与视觉的**语义**相似度。然而，视频的一致性可能还包含非语义的维度，例如特定的运动风格、光影氛围等，这些很难用文本精确描述。未来的研究可以探索多模态检索，结合视觉相似性、运动相似性等多种线索。
- **超参数的经验性选择:** 记忆容量 $b$ 和 `SMA` 中的 $k$ 值等关键超参数是通过实验经验选择的。未来可以研究如何让模型自适应地决定需要多大的记忆容量或激活多少记忆，而不是使用固定的值。

## 7.3. 个人启发与批判
- **个人启发:**
    - <strong>“按需查询”</strong>的记忆范式: `MemFlow` 最具启发性的一点是它将记忆从一个被动的“存储器”转变为一个可被主动“查询”的“数据库”。这种“按当前任务需求，索取相关历史经验”的思路，非常符合人类的认知模式，具有极强的通用性。它可以被迁移到许多其他需要长上下文的生成任务中，例如：
        *   **长篇故事生成:** 在生成新章节时，根据章节大纲（提示）检索历史章节中的关键人物或情节线索。
        *   **多轮对话:** 根据当前用户问题，检索对话历史中最相关的上下文。
        *   **复杂代码生成:** 在编写新函数时，检索项目中已有的、功能相关的函数作为参考。
    - **平衡全局与局部的重要性:** 记忆容量的消融实验揭示了在长序列建模中，盲目扩大上下文窗口（全局记忆）并不总是最优解。如何精巧地平衡长期依赖（全局）和短期动态（局部）是一个核心挑战，`MemFlow` 对此提供了有价值的实践探索。

- **批判性思考:**
    - **通用性声明有待验证:** 论文声称其方法与“任何带有 KV 缓存的流式视频模型”兼容。虽然理论上可行，但 `MemFlow` 的效果可能与基座模型的架构、训练方式等因素强相关。该声明需要更多在不同模型上的实验来支撑。
    - <strong>“可忽略”</strong>的计算负担: 7.9% 的速度下降对于学术研究来说确实很小，但对于追求极致性能的工业级实时应用，这仍然是一个需要考量的成本。在某些场景下，这个 trade-off 可能需要重新评估。
    - **对高质量“教师模型”的依赖:** `MemFlow` 的训练依赖于 `Self-Forcing` 范式，即需要一个强大的“教师模型”来提供监督。这意味着该方法的性能上限在一定程度上受限于教师模型的质量，这可能是其在实际部署中的一个依赖项。